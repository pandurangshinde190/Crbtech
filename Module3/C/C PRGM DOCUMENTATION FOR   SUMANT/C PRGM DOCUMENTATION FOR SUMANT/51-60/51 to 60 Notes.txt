The general syntax of an expression in which comma ( , ) acts like an operator is as below -

(expression1), (expression2), (expression3), .......,(expression-n)

1. In this (above general syantax) comma (,) is perfectly acting as the operator.
2. The expressions has to be executed from LHS to RHS.
3. The right hand side expression should be executed with all the side-effects of left operand.
   (It will be clear when u'll go through the code of it)
4. The value of right most expression is the value of whole expression.
5. Comma is the operator with least precedance.

Compound assignmnet operators
-----------------------------

+=
-=
*=
/=
%=
&=
^=
|=
<<=
>>=

Note :- In comparison with normal assignment always compound assignment operator works bit faster
Wherever it is possible to go for compound assignment operation there always 
try avoiding normal assignment


Importance Of Expression w.r.t standard general syntaxes of few elements :-

----------
----------
----------
initialization
while( condition )
{
   ----------
   ----------
   ----------
   increment / decrement 
}
----------
----------
----------


i = 1;
while( i<=10 )
{
    printf("\n%d", i);
    ++i;
}

printf("\n%d", i); //o/p:- 11


switch statement in 'C' (Selective Statement)

what is this so called choice ?



switch(An expression is required which evaluates to an integer value)
{
 case label_1 :
              ---------
              ---------
              break;
case label_2 :
              ---------
              ---------
              break;
.
.
case label_n :
              ---------
              ---------
              break;

default     :
             ----------
             ----------
             break;
}


Functions :
-------------
Parameter Passing and 
returning some value from the function 

Function Call's general syntax is :-

functionName( arguments are to be passed if required and seperated by a comma ) ;

what is meant by "argument" ? 
Again it's a valid expression.

eg:- add( (a>b)?(a):(b) , !(5==printf("Hello")) );

checkLeapYear( year ) ;


"return" statement in C 
On of the way in which return statement can be constructed 
-----------------------------------------------------------

storage_class return_type function_name( arg list seperated by a comma )
{
 -----------
 -----------
 -----------
 return expression ; 

}

return value/variable/constant value ; --> Fine to some extent but not the exact one

Expression :
------------

In general an expression is a valid combination of the operands and the operators.
Not necesarily always you will have some combination (Even a single variable or a single constant
or even a function call provided the return type is not-void is considered as an expression)

eg:- 
int a=10, b=20, c=30, d=1, e=0;
int x, y, z;
int result;

Examples of few expression 

a + b
x = a + b
a - b
x = ++a
++a
++10 //Invalid. Compile Time Error :- L-Value required
10
0
1
-5
a
b
c
d
10+20
'A' is equivalent to 65 
sizeof(int)
sum = sum + rem
sum += rem
a > b   (Relational Operators :- <, <=, >, >=)
c >= d
a < x
b <= x
a == b  (Comparison Operators :- ==, !=)
c != d
a && b  (Logicl Operators :- && (AND), || (OR) )
c || d 

!(expression)  

!a            (Unary NOT ( ! ) :- It turns the result from TRUE to FALSE and Vice -Versa)
!(a>b)
!0
!(a==b)

function calls (provided the return type is not "void")

add(a, b)
printf("Hello, World")  --> This is also a function call 
                            You are calling the built in function printf 
                            The value returned by this b.i.f. printf is substituted at the place 
                            of the function call

scanf("%d%d%d", &x, &y, &z) 

Rule 1:- In C/C++ every expression holds a value of it's own.

Assignment Operator :- = 

Comparison/Equality Operator :- == (read it as - equal equal to ), != (not equal to)


Rule 1:- In C/C++ every expression holds a value of it's own.
Rule 2:- A quantity identical (exactly) to zero (0) is considered as "FALSE".
         And any quantity which is non zero (+ve and -ve quantities) is considered as "TRUE"

expression1 == expression2

Firstly understand that "expression1 == expression2" itself is a valid expression.
If value of expression1 and expression2 is same then, the value of resultant expression is supposed 
to be TRUE
If value of expression1 and expression2 is different then, the value of resultant expression is supposed 
to be FALSE

expression1 != expression2

Firstly understand that "expression1 != expression2" itself is a valid expression.
If value of expression1 and expression2 is different then, the value of resultant expression is supposed 
to be TRUE.
If value of expression1 and expression2 is same then, the value of resultant expression is supposed 
to be FALSE.



Rule 1:- In C/C++ each and every expression holds a value of it's own.

Rule 2:- A quantity identical (exactly) to zero (0) is considered as "FALSE".
         And any quantity which is non zero (+ve and -ve quantities) is considered as "TRUE"
         Hint :- In discussion of !, &&, || operator this rule will help you out a lot

Rule 3:- An expression involving the use of ==, != (i.e. the comparison operator), 
         >, >=, <, <=  (Relational Operators), &&, || (Logical Operators)
         gives the result either as TRUE or FALSE.
         If the result is TRUE then value of that expression is 1.
	 If the result is FALSE then value of that expression is 0.


Relational Operators :- ( >, >=, <, <= )

"expression1 > expression2"

Very firstly u need to understand that "expression1 > expression2" itself is an expression and 
will have a value of it's own.
This value is either TRUE or FALSE.
if value of expression1 is greater than value of expression2 then value of the resultant expression
is TRUE else it is FALSE.
True means 1
FALSE means 0

Here we have discussed out > operator.
Rest three i.e >=, < and <= are very similar


//I want to check whether 'a' lies between 1 and 20 ( excluding the extremity)
So, here I need to use the LOGICAL-AND (&&) operator


Logical Operators :- &&, ||


Logical AND ( && )
-------------------

(expression1) && (expression2) :- read it as "expression1 AND expression2"

"(expression1) && (expression2)" is also considered as a valid expression. 
This expression will also have a value of its own.
This value is either TRUE or FALSE.
If it's TRUE  then the value of it is 1
If it's FALSE then the value of it is 0

expression1	expression2	expression1 && expression2
   T		  T			T
   T		  F			F
   F	 	  T			F
   F		  F			F

Note :- In case of logical AND the resultant expression will evaluate as TRUE if and only if
        both the expressions are TRUE. 
        If either of the expression is FALSE then the resulant expression would turn out to be 
        FALSE


Logical OR ( || )
-------------------

(expression1) || (expression2) :- read it as "expression1 OR expression2"

"(expression1) || (expression2)" is also considered as a valid expression. 
This expression will also have a value of its own.
This value is either TRUE or FALSE.
If it's TRUE  then the value of it is 1
If it's FALSE then the value of it is 0

expression1	expression2	expression1 || expression2
   T		  T			T
   T		  F			T
   F	 	  T			T
   F		  F			F

Note :- In case of logical OR even if any one (either) of the expression is TRUE then the resultant 
        expression will turn out as TRUE.
        If both the expressions evaluate as FALSE then the resultant expression would be FALSE


Hint :- Whenever we have an expression which is internally consisting of few sub expressions.
        And these sub-expressions if are connected with the AND / OR condition then 
        In construction of such an expression we require to use Logical AND /
        Logical OR operators



int a = *** ; 

if(1 < a  < 20)
{
	-----------
}
else
{
	------------
}

In above if-else never ever the else block will execute.
So, you might be u'll also have a warning :- UN-RECHABLE CODE 

//I want to check whether 'a' lies between 1 and 20 ( excluding the extremity)
So, here I need to use the LOGICAL-AND (&&) operator

So,it means
1. 'a' should be greater than 1 ----> (a>1)
and ( There is a compulsion not a option that you are having )
2. 'a' should be less than 20   -----> (a<20)


(a>1) && (a<20)


int a = *** ; 

if((a>1) && (a<20))  --> Now it will check whether a lies between 1 and 20
{
	-----------
}
else
{
	------------
}

Short circuit evaluation
------------------------

S.C.E is associated in the discussion of Logical-AND (&&) and Logical-OR (||) operator

In case of && the expression is constructed as - 
(expression1) && (expression2)
The whole expression evaluates as TRUE if and only if both the expressions are TRUE.

In LHS-->RHS execution if expression1 evaluates as FALSE then, expression2 is not executed
as the resultant expression is any ways gonna be FALSE.


In case of || the expression is constructed as - 
(expression1) || (expression2)
The whole expression evaluates as TRUE even if either of the expression is TRUE.

In LHS-->RHS execution if expression1 evaluates as TRUE then, expression2 is not executed
as the resultant expression is any ways gonna be TRUE.

(Expression1- True) ||  (Expression2 - Will not be executed)
(Expression1- FALSE) && (Expression2 - Will not be executed)


Rule 1:- In C/C++ each and every expression holds a value of it's own.

Rule 2:- A quantity identical (exactly) to zero (0) is considered as "FALSE".
         And any quantity which is non zero (+ve and -ve quantities) is considered as "TRUE"
         Hint :- In discussion of !, &&, || operator this rule will help you out a lot

Rule 3:- An expression involving the use of ==, != (i.e. the comparison operator), 
         >, >=, <, <=  (Relational Operators), &&, || (Logical Operators) and ! (Unary NOT operator)
         gives the result either as TRUE or FALSE.
         If the result is TRUE then value of that expression is 1.
	 If the result is FALSE then value of that expression is 0.



Unary NOT Operator ( ! )
Note :- At some cases (few textbooks/ references) it's also refered as Logical Not Operator
--------------------------------------------------------------------------------------------

! is a unary operator.
It has to be applied on the LHS of the operand.
operand precisely mean - "an expression"

So, the general syntax of getting an expression created with ! operating as a operator is :-
!expression

suggested to have () for the expression just for readabilty purpose
!(expression) //wise and a good programming practice

"!(expression)" :- Is firstly a valid expression. 
As such it will also have a value of its own.
This value again would be either 0 or 1.

So, the rule to be remembered is -
!(True) is  False
!(False) is True

A quantity identical (exactly) to zero (0) is considered as "FALSE".
And any quantity which is non zero (+ve and -ve quantities) is considered as "TRUE" 

Even we can apply the operator as many times as we want 

eg:- 

!!(True) //Read it as Not of Not of True 

As it's a unary operator the associativity is from RHS to LHS So,

!FALSE
True

Conditional/Ternary Operator :-
--------------------------------

The operator symbol for conditional operator is ?: 
The nature of it is -"ternary" i.e. it's arity is 3.
The associativity of this operator is as well LHS to RHS (*****)

The general syntax of using this operator in creation of an expression is as below - 

expression1 ? expression2 : expression3 

(expression1) ? (expression2) : (expression3) 

Note that this complete stuff "(expression1) ? (expression2) : (expression3)"
that you have created itself is a valid expression.

   Here expression1 is first executed. Value of expression1 is to be considered. 
   If expression-1's value is TRUE then - expression-2 is executed and value of expression-2 
   is supposed to be the value of whole i.e. complete expression.
   If expression-1's value is FALSE then - expression-3 is executed and value of expression-3 
   is supposed to be the value of whole i.e. complete expression.


int a=10, b=20, c=30;
int Result;

Result = (a!=20) ? (expression-2) : (a+b+c)  ; 
printf("\nValue of Result is %d ", Result);   //o/p:- 60


something about printf
----------------------

1. printf is a built-in-function
2. It's declared in the header file stdio.h (Note :- It's not defined in stdio.h)

Note :- Standard built-in header files do not contain the definations of the functions. 
        It contains the declaration only.
        Defination is present inside the .lib (DOT LIB) folder

3. return-type of the b.i.f printf is "int". It returns the total number of arguments printed
   successfully on to the console.
4. Because of this a call to the b.i.f printf is also considered as a valid expression.
   Because at the place of function call the return value is substituted


eg:- 

int a = printf("Yash");
printf("%d", a);

output :- Yash4



Nesting of conditional operator 
--------------------------------

Nothing new in this to discuss out
The general synatx of expression in which conditional operator operates is - 
(expression1) ? (expression2) : (expression3) 

Here in place of any of these expression's (expr-1 or expr-2 or expr-3)
we can have an expression which again is involving the use of conditional operator.

Note :- This nesting can go upto any level. Just stick to the basic fundamental principle for
it's execution.


Swapping of two integers  (In possible different ways)
-------------------------------------------------------

Q/A). Please perform swapping of two integers just by using a single statement.

int a=10, b=20;

----------------- ;

printf("\n%d  %d", a, b ); //o/p is expected as :- 20 10 

Statement:
-----------

"Statement" is nothing but it truly represents some instruction/order for the computer.
Generally when an expression is terminated with a semicolon that turns out to be an example of statement.

eg:- sum = a + b ----> This is an expression
     sum = a + b ; ----> This is a statement

We say that semicolon (;) is the statement terminator.


Types of statements in 'C'

I) Decision Making Statement

- if (simple if)
- if - else
- nesting of if-else (nested if else) --> Just a concept i.e it's 
                                          just an extension to what u have studied

II) Selective Statement

- switch

III) Iterative Statement (Loops)

- for 
- while
- do while 

IV) Branching Statement

- break
- continue
- goto 

eg:- below mentioned "if" is purely representing a statement.
It's representing an instruction to the computer/machine
But note - it's not terminated with a semicolon 

Note :- Not necesarily each and every statement is terminated with semicolon always.

if(a>b)
{
 ------
 ------
}

I) Decision Making Statement 

a. if (simple if)

If it rains then I will be carring my rainwear with me.

The general syntax of writting a simple if - 

int a = 5;
-----------
-----------
-----------
if( expression )
{
  ------------
  statement/t's
  ------------
}
-----------
-----------
-----------

1. All the statements which are placed above if will be executed sequentially as per the top-bottom
principle

2. Firstly expression is compulsory in the round brackets of if.

3. The expression written in the round brackets of if is completely executed.
As studied earlier - this expression will also have a value of it's own.
If the value is identical to zero then it's considered as FALSE
If the value is non-zero (+ve or -ve) then it's considered as TRUE

4. If expression evaluates as TRUE then the block of if is executed.
If expression evaluates as FALSE then the block of if is not executed.
Note :- In case of "simple if" you have control over just a single set/single block of code

5. The statements which are written outside the block of if (i.e. below the end of block of it)
will anyways be executed. i.e. irresepective of the expressions value as TRUE or FALSE
It has to execute.

6. In case there is a single/unique/"one and only one" statement associated with the block of if.
Then the block is optional.
If you observe a "simple if" without any block to it ( {---}) then, 
the immediate single statement written below if should be considered as if inside the body of it.

if(a>b)
{
 printf("\na is greater than b");
}

The above if could be written as - 

if(a>b)
printf("\na is greater than b");

one more example

int a = 10, b= 5;

if(a<b)
   printf("Yash");
   printf("Yash");  //From this point the statemet's are supposed to be out side the block of if.
   printf("Yash");

printf("Shweta");


if(a<b)
{
   printf("Yash");
}
   printf("Yash");
   printf("Yash");

printf("Shweta");

o/p:- YashYashShweta

7. In the source code we are free to use as many if statements as we want.


b. if - else
-------------

-----------
-----------
-----------
if(expression)
{
 ---------
 Statement/t's
 ---------
}
else
{
 ---------
 statement/t's
 ---------
}
-----------
-----------
-----------


1. Firstly all the statements written above if will be executed top to bottom sequentially as per the 
principle

2. The expression in the round brackets of if is again mandatory

3. The expression is completely executed. After complete execution of the expression based upon the 
value of the expression we decide whether it's TRUE or FALSE.
If expression value comes out identical to zero - FALSE
If expression value comes out non zero (+ve or -ve) - TRUE

4. If expression's value is TRUE then the block of if is executed and the block of else is not executed.
If expression's value is FALSE then the block of if is not executed but, block of else is executed.

5. In case of if-else either if OR else block executes (Based on the value of the expression). 
Execution of both the blocks at same instance of time is an impossible task 

6. The code which is written outside the "else" will any ways be executed sequentially following 
the top-bottom principle.

7. In case of "simple if" we have a single block/set of code. And we simply decide whether to execute 
that block or not. That means we gain control over a single block of code.
In case of "if-else" we truly have 2 blocks/set's of code i.e. if block and the else block. 
So, out of these two blocks we decide which one to execute and which one not to execute 
(skip the execution).
We are gaining control over two different blocks/set of code. 

8. "else" is always associated with if. 
Above else immediately you will be having "if".
"if" can exisist indipendantly (like we saw in case of simple if)
"else" can't execute independantly. 
After closing of if and before starting of else we can't have any statement placed.
we can't seperate else from if.

9. In case of if-else as well - 
If there is a single statement associated with the "block of if" OR "block of else".
Then here as well the block is optional. You are free to skip it.

In other words - If you observe an if-else without any block associated with it (if / else/ both)
then, the immediate single statement falling below the block should be considered as if inside the 
body of it.


Suggestion :- Never skip the block. Let it be present. It increases the readability of the code.

10. Again like "simple if" you are free to use as many "if-else" statement's as you want in your code.
Even nesting of it is allowed (nested if-else)


int a = 10, b=20;


if(0)
{
   printf("a is greater");
}
else
{
   printf("b is greater");
}

Same can be written as - 

if(0)
 printf("a is greater");
else
 printf("b is greater");

Let's try this now :

int a = 10, b=20;

if(a!=b)
  printf("a is greater");
  printf("\na is greater");
else
  printf("b is greater");
  printf("\nb is greater");

printf("Out of if-else");


if(a!=b)
{
  printf("a is greater");
}
  printf("\na is greater");  //--> This is not a part in the body of "if"

else                         //--> The else is totally seperated from "if"
  printf("b is greater");
  printf("\nb is greater");

printf("Out of if-else");

CTE :- misplaced else / else without if


c. Nesting of if-else (Nested if - else)
----------------------------------------

if(expression)
{
   if(expression)
   {
    --------
   }
   else
   {
    --------
   }
}


if(expression)
{
   if(expression)
   {
    --------
   }
   else
   {
    --------
   }
}
else
{
   if(expression)
   {
    --------
   }
   else
   {
    --------
   }
}

In case of simple if 
OR
In case of if-else
We are allowed to place/write simple if / if-else inside any of the mentioned block. 
This is what term it as - nesting of if-else.

This nesting can go upto any level.
Too much of nesting should be avoided as it reduces the readability. Even the code starts travesing
towards the right most bottom of the screen as we are maintining the indentation.
The basic working principle remains the same 

Note :- if-else VS Conditional Operator

A statement constructed with the help of ?: can be replaced with if-else as well. This is 100% true.
But, vice-versa is not necesarily true. 
Not necesarily each and every if-else is able to be substituted by ?:

Q/A). Which sort of if-else can be substituted by ?: 
Ans:- Home work

II) Selective Statement 
------------------------

a). switch 

switch is simply a "statement" available for use in the P.L.
It serves as an example for "selective statement"

The general syntax of writting a switch statement is as below - 

-----
-----
switch( expression )
{
case label-1 :       --------
                     --------
                     break;
case label-2 :       --------
                     --------
                     break;
.
.
.
case label-n :       --------
                     --------
                     break;
default      :       --------
                     --------
                     break;
}
-----
-----

1. All the statements above switch will be executed sequentially following the top-bottom principle

2. The expression for the () of switch is mandatory. This expression is completely executed.
   Note :- The expression should evaluate to an integer type quantity. Character constants are 
   internally represented in the form of ASCII value which is integer type quantity as well.
   So even this is fine.

3. After executing the expression the control is supposed to enter into the body of switch along with 
   this value of the expression.
   Whichever label with which the expressions value matches - there then, the coresponding set of 
   code is executed sequentially. 
   In this sequential execution the "break;" statement which is generally written at the last also
   gets executed as a result of which the execution of switch is terminated and the control comes 
   out of the switch to execute the rest of the statements.
   
   Ideally "break;" is expected for each and every set of code w.r.t each and every case.
   The purpose of "break;" is to terminate the execution of switch statement when required.
   If "break;" is not found then the execution goes on and on until either "some break is found"
   OR "switch ends". This is called as "FALL-THROUGH in switch"


4. The "Label" can't be repeated. It should be unique.
   The "Label" has to be a "constant-integer-expression" (An expression which is involving only
   the constants and which is finally evalauting to an integer value). No variable is allowed 
   in place of label in any term.
   Character constants (i.e. enclosed inside single quote) can also serve as the label 


5. The cases can be written in any any order. 
   Even we are free to write the "default" at the start itself.
   "case"/"break"/"default"/"switch" these are just the keywords present in C.

6. "default" handles every case which remain unhandeled.
    Note :- "default" is optional. If you wish then feel free to skip it as well.
    We can observe "default" written at the last and still a "break;" associated with it.
    This is just to avoid the switch from entering into "fall-through" - in case few more cases
    are added later on below the default. 


if(expression)
{
   -------
   -------
   -------
   -------
   if(expression)
   {
     --------
     --------
   }
}
else
{
   -----------
   -----------
   -----------
   if(expression)
   {
    --------
    --------
   }
   else
   {
    --------
    --------
   }
}


"exit"
-------

exit is nothing but it's a built-in function.
It's declared inside the header file "stdlib.h". So, if you are using/calling the exit function 
then, ideally you should include the header file "stdlib.h" in your source code.
The declaration of "exit" function is as below - 

void exit(int status) ; 

This function terminates the execution of the program.
eg:- exit(1);
     exit(5);
     exit(10);
     exit(17);
     exit(0);

So, in all the above cases the working of exit function would be exactly the same.
In all the cases as discussed it will terminate the program execution.

The integer value that we pass as an argument to exit function just represents the status i.e.
it represents the total no. of problems/issues because of which we are terminating the code.
It is just a convention / standard practice

Usually you will observe "exit(1);"

"exit(0);" ---> It represents normal termination i.e. without any issue/problem.

System.exit(1); ---> Do it in Java


In case of nested if-else :-

If possible this should be avoided.
It makes the task a bit complex. It decreases the readabiltiy of the code.
The code starts travelling towards the right bottom of the screen ( bcz of the indentation )
Upto 1/2 level's it's fine.


simple if - terminated with a semicolon 
----------------------------------------

if( expression );
{
   --------
   --------
   --------
}

semicolon is the "statement terminator" in C Programming Language.
eg:- If you observe a simple if which is terminated ahead with a semicolon then the meaning of it is - 

1. It's an if without any body/statement associated with it. 
2. If you observe any block below such an if then, just consider it as an arbitary block of code.
   It's not the block of if. (Block of if is not into existance)
3. On a safer note - such a simple if can be considered as an if with empty body (Technically Incorrect)




if-else - In which the if / else is terminated with a semicolon 
----------------------------------------------------------------


Try-Out

if (a == 10)
	printf("\ni am in if ");
	printf("\ni am in if ");
	printf("\ni am in if ");
else
	printf("\ni am in else");
	printf("\ni am in else");
	printf("\ni am in else");

if (a == 10)
{
	printf("\ni am in if ");
}
	printf("\ni am in if ");
	printf("\ni am in if ");
else
	printf("\ni am in else");
	printf("\ni am in else");
	printf("\ni am in else");
	

In case of if-else in which the if is terminated with a semicolon. 
If there is at least a statement written/placed/coded below if then this has to give you an error.

eg:- 
if (b == 20);
	 printf("\nI am in if block");
    else
	 printf("\nI am in else block");

Error :- Illegal else without a matching if. 


Q/A). Can you write an if-else in which the if would be terminated with a semicolon. 
      But, there should not be any compile time error.

Ans :- Yes!!!! It is possible. 
       In this case we should not have any single statement written/coded below if. 
       Directly below if we should have the else part

eg:- if (expression);
     else
     {
       -------------
       -------------
     }


else terminated with a semicolon in case of if-else

eg:- 

if (b == 20)
	{
		printf("\nI am in if block");
	}
	else;
	{
		printf("\nI am in else block");
	}


In this case as well -
1. Consider else without any body/statement associated with it.
2. The block of code / statement which you observe below else should be considered just
   as the normal arbitary set of statement's which will be executed sequentially. 

Q/A) What is the minimal way in which we can write just a single pair of if-else

if (expression);
else;


switch terminated with a semicolon
-----------------------------------

Just like we saw - 
1. simple if terminated with ;
2. if and else terminated with ; in case of (if-else)

we can even have a switch which is terminated with a semicolon.
Syntatically this is allowed and fine.
If you do so - then it's considered as a switch without any body to it.
And the block that if you observe below switch - is just a arbitary block of code. It should not
be considered as the block of switch.


Something more about switch 
-----------------------------

1. Considrering the opening bracket of switch as a opening of a block we are allowed to define
   a variable over there.

eg:-

switch (2)
	{
		int a=10;
            

switch (2)
	{
		int a;


2. Note that :- switch is actually not for defining the variables. 
   Any variable defined as per point no-1 just seems to be defined. Truly speaking no such variable 
   is created. If you try to access it then you will get a Compile Time Error

eg:-

switch (2)
	{
		int a=10;
	case 1:  printf("\nI am for case-1");
		break;
	
	case 2:  printf("\nI am for case-2. Value of a is %d ", a);
		break;

	default: printf("\nInvalid Choice");
		break;
	}

C.T.E :- Un-initialized local variable 'a' used 

3. A variable can be defined in execution of those statements which are associated with some 
particular case. This is allowed and works fine. (Tested on VS 2010)

eg:- 

switch (2)
	{
	case 1:  printf("\nI am for case-1");
		break;
	
	case 2:   int a = 10;
		       printf("\nI am for case-2. Value of a is %d ", a);
		break;

	default: printf("\nInvalid Choice");
		break;
	} 




III) Itterative Statement (Loops)
---------------------------------

Iterative statement will help us in performing something which is termed as - "an iteration".
Iteration means to perform some similar task again and again (It could be for some decided no. of times
OR at times we even require to go for infinite time i.e. where the total no. of repeations are not 
known)

a) for 
-------
The general syantax of writting a for loop is as below - 

-----------
-----------
for(expression-1 ; expression-2 ; expression-3)
{
  --------
  --------
  --------
}
------------
------------

1. "for" is simply a keyword in 'C'. It represents one of the iterative statement (i.e. for loop)

2. All the statements above the for loop will execute sequentially i.e. following the top-bottom 
   approach as per the principle

3. In execution of "for" expression-1 is firstly executed. 
   Note :- expr-1 is executed only once in case of "for" and that is at the START.

4. After that the control comes on to expression-2 and executes it completely as well.

   If expr-2 evaluates as TRUE then, the control goes into the body of for and executes all the
   statements sequentially.
   Then, the control moves to execute expression-3 and gets it executed.
   After executing expr-3 the control comes to expression-2. Once again get's it executed.
   If it is TRUE -------> again the same process is repeated  [ Iteration ] 
   
   If expr-2 evaluates as FALSE then, the control is not going to enter into the body of loop.
   Rather, the control will move out of the loop to execute the rest of the statement's in sequence.
   This is what we say as - "The execution of the loop is terminated"

5. for-loop terminates - 
   a. Because of expression-2 evaluating as FALSE.
   b. we can use "break;" statement and get the loop terminated explicitely.

6. "for" is an example of "pre-tested-loop". 
    The minimum no. of times for loop can execute is zero. 

7. Like simple-if and if-else. In case of for as well - If there is a single statement associated with 
   it's body then the {} are optional. You are free to skip it.
   In other words if you observe a for-loop without any {} associated with it. Then, the immediate
   single statement written below that for should be considered as if inside the body of it.

for (i = 1; i <= 100 ; ++i)
{
	printf("\n%d", i);
}

printf("\n%d", i);
printf("\n%d", i);

o/p :- 1  2  3 ..   99  100  101  101 


Few More Inputs about For
---------------------------

1. expression-1 in case of "for" is optional (Offcourse ; has to be there).
Whatever we are about to do in the place of expression-1 can be done anywhere before entering into 
the body of the loop.

2. expression-3 in case of "for" is also optional (Offcourse ; has to be there).
After executing the core-body and before going on to the expression-2 we can get the 
increment/decrement happen. It would be in the place of expression-3 OR we can do it - 
in the body of for at the last.

what about expression-2 (condition) ? Is it optional as well !!! ?

3. Even expression-2 in case of "for" is optional. 
In case expression-2/condition is missing in case of "for" then it should be assumed as TRUE.

Note :- expression-2/condition is optional in case of "for"
        It is mandatory in case of "while" and "do-while" 


b) while 
---------

---------
---------
expression-1
for(  ; expression-2 ;  )
{
 -------
 -------
 -------
 expression-3
}
---------
---------


The general syntax for writting "while-loop" is as below - 

---------
---------
expression-1
while(expression-2)
{
 -------
 -------
 -------
 expression-3
}
---------
---------

1. Here as well all the statements written above "while" will be executed sequentially one after 
the other following the top-bottom approach. In which the "expression-1" is completely executed.

2. expression-2 is mandatory for the () of while. The control executes this expression-2.
   a. If expr-2 evaluates as TRUE - then the body of the loop is executed in which the expression-3
   which is written as the last statement (inside the body) also gets executed.
   After executing "expression-3" the control again moves on to the expression-2. Again expression-2 
   is executed. If it is TRUE then again body is executed and after body again control will move to
   execute expression-2. This is what we term it as - "iteration". It will continue as long as - 
   expression-2 is evaluating as TRUE

   b. If expr-2 evaluates as FALSE - then the control is not going to enter into the body of the loop.
   Here the execution of loop is supposed to be terminated.

   Note :- Value identical to zero in any form is considered as FALSE. And non-zero quantity
           is considered as TRUE.
   
3. Once the loop-terminates then the control goes to execute the rest of the statements which are 
   written below the while loop.

4. Like simple-if , if-else, for . Here as well - in case there is a single statement associated with
   the body of while then the {} is optional.
   In other words - if you observe a while without any {} associated with it. Then, the immediate 
   single statement written below while should be considered as if inside the body of it.
   Note :- We can happily have a while loop consisting of a unique statement as in the body of it.

5. while serves as an example of - "pre-tested-loop".
   i.e. the minimum no. of times a while loop can iterate is - zero
   (If expression-2 turns out FALSE at the very first time)

6. "while-loop" terminates 
    a. Because of expression-2 evaluating as FALSE.
    b. We can explicitely get the loop terminated with the use of "break;" statement.

7.  expression-3 which we generally code as the last statement in the body of while is 
    off course not mandatory. Whatsoever body we have that body will be executed (provided
    expr-2 is evaluated as TRUE)


TryOuts
--------
i = 1;
	
while (i <= 100)
{
	printf("\n%d", i);
}
++i; //This statement will fall out of the body of while 
     //Warning :- Unrechable code 

o/p:- 1
      1
      1
      .
      .



while(1)
{
  -------
  -------
  -------
}

1. The above loop has integer-1 placed in the position of expression-2 i.e. condition.
   1 is a non-zero quantity as such it's considered as TRUE. 

2. Because of this - such a loop will go for infinite iteration. 
   Such a loop will not terminate because of "expression-2" evaluating as FALSE.
   If we wan't to terminate such a loop then we have to explicitely make use of the "break;"
   statement from the body of the loop.

3. In the round brackets of while we generally write integer 1 w.r.t the standard over it.
   But, instead of 1 feel free to write any any non-zero quantity. It will have the same
   effect w.r.t the execution.



c) do-while
------------ 

The general syntax of writting a "do-while" loop is as below - 

----------
----------
----------
expression-1
do
{
   ----------
   ----------
   ----------
   ----------
   expression-3
}while(expression-2);
---------
---------
---------

1. Here as well all the statements written above "do" will be executed sequentially in which the 
expression-1 is also executed.
expression-1 not necesarily should be written immediately above "do". We can write it any where 
above do as we wish.

2. Then the control directly enters into the body of the do (No condition/ No TRUE/ No FALSE criteria)
and executes the body sequentially. In which "expression-3" is also executed.
"expression-3" is generally written as the last statement in the body of "do".

3. After executing the body for the very first time then move on to the "expression-2" written in the 
() of while. Execute the expr-2 completely. 
a. If it is TRUE then again execute the body. Then again execute expression-2. If again it's TRUE 
then again execute the body ---------this goes on and on untill expression-2 evaluates as FALSE
(Iteration)
b. If expression-2 evaluates as FALSE then the execution of loop is supposed to be terminated and the
control moves out of the loop to execute the rest of the statements in sequence.

4. "do-while" serves as an example of "post-tested-loop". The minimum no. of times a do-while 
can execute is 1.

5. The expression-2 i.e. the so called condition for the () of while is mandatory. Like for it's not
optional in case of do-while

6. In case of "for" and "while" we can write the loop without {}. In such a case the immediate single
statement written below the loop is considered to be inside the body of it. 
This is not a Compile Time Error

Unlike this in case of do-while - if there are mutiple statements associated with the body then {}
is mandatory. We can't skip it. Any attempt done towards this will give you a compile time error.

7. In case there is a single statement associated with the body of while. Then here as well we are free
to skip the {}.

8. do-while loop as well terminates because of "expression-2" evaluating as FALSE.
   OR
   It can be explicitely terminated from the body itself by using a "break;" statement 


Nesting of Loops
-----------------

1. Nesting of loops is very similar with the nesting of if-else

2. Inside the body of any loop (for, while or do-while) we are actually allowed to write/code
   any other loop (for, while or do-while).
   The inner loop is supposed to be nested within the out-loop

3. The nesting can actually go upto any level.
   But too much of nesting should be avoided - it decreases the readability and makes the task complex
   to understand and dry run.

4. For every iteration of the outer-loop the inner-loop is supposed to execute completely.
   If the outer loop iterates for 3 times and 
   If the inner loop iterates for 3 times then the total number of iterations are - "3*3 = 9"

   
"break" statement
------------------

The general synatx of using "break" statement is as below-
break ;

As of now we observed "break;" statement for the very first time in case of "switch"
eg:-
 switch( choice )
 {
  case 1 : ------
           ------
           break;
  .
  .
}
There becuase of execution of the break statement - the execution of switch is supposed to be terminated.
And the control comes out of the switch to execute the rest of the statements

"break" statement can even be placed inside any loop. If such a break statement gets executed
then the execution of that loop is terminated and the control comes out of the loop to execute the 
rest of the statements.

Consider we have nesting of loops -
i.e. we have a outer loop and in which we have a inner loop.
Assume that "break;" statement is present inside the body of inner loop.
Then, due to execution of such a break statement the "inner loop" will terminate.
It's applicable only for the "inner-loop".
In case you want to terminate the outer loop as well explicitely then - we need to use "break;"
one more time for the outer loop explicitely.


"continue" statement
--------------------

The general syntax of writting "continue" statement is as below - 
continue ;

The statement "continue;" can be used only inside some loop (not in case of switch)

If the continue staetment written inside some loop executes then as a result of it - 
The control moves to take the next iteration
i.e. The set of code which is falling below the continue and which is inside the loop is skipped 
for that particular iteration.

Consider we have nesting of loops -
i.e. we have a outer loop and in which we have a inner loop.
Assume that "continue;" statement is present inside the body of inner loop.
Then, due to execution of such a "continue" statement the control will move to take the next iteration
of the inner loop.
It's applicable only for the "inner-loop".
In case we want to use it seperately for the outer loop then we need to specify it explicitely 
for the outer loop as well.


In case of loop :- 

1. Wherever the concept of "iteration" is there - there we are free to make use of any loop of 
our choice

2. Any task which you can do using "for" can alternatively be done by "while" or "do-while"
   Any task which you can do using "while" can alternatively be done by "for" or "do-while"
   Any task which you can do using "do-while" can alternatively be done by "for" or "while"

It is just a matter of choice.

Q/A). What is the basic difference between "for" and "while" ?
      When should I use "for" and when should I go for "while" ?

Ans :- "for" is generally used for iteration over known no. of times.
       "while" is generally used for some undefined no. of iterations.


Note :- A variable in 'C' ideally has to be defined at the start of a block (Not necesarily it should 
be a start of main).
It could be a start of any of these below blocks - 
1. arbitary block
2. block of for/while/do-while
3. block of if / else
4. block of any user defined function

A variable defined in a particular block is alive only within that block. 
After complete execution of that block (In which it is defined) the variable is no more alive.
Any attempt done to access it - will give you a "compile time error"


TryOut
------

int a = 10;

if(a==10)
{
    printf("\nLove You");
    printf("\nLove You");
    break;
    printf("\nLove You");
    printf("\nLove You");
}

---------------------------------

if(a!=10)
{
   
}
else
{
   break;
   printf("\nHate You");
   printf("\nHate You");
   printf("\nHate You");
   printf("\nHate You");
}


"break" statement can't be used for - independant if / if-else.
It is not used for terminating the if/else.
Any attempt done to do so will lead to a compile time error -"illegal break"
break  is used only inside a loop / switch .

Similarly "continue" is also only for a loop.


for loop terminated with a semicolon 
-------------------------------------

for(expression1 ; expression2 ; expression3 );
{
 --------
 --------
} 

for(expression1 ; expression2 ; expression3 )
                     ;
{
 --------
 --------
} 

for(expression1 ; expression2 ; expression3 )
{
     //Empty Body
}                    
{
 --------
 --------
} 

In case we have a for which is terminated with a semicolon then - we need to consider it as a loop 
without any single statement/body associated with it.
For easy understanding we can think of it as a loop with empty body (This is technically incorrect. 
But, it's just for ur understanding)

The block of code which might be observed below such a for loop - is not the body of the for.
Rather, it's just a arbitary block of code which will execute in sequence (i.e. once in the top-bottom
execution)

eg:-

for (i = 1; i <= 10; ++i)
{


}             
{
	printf("%d\n", i);
}


Minimal form of "for loop" / Shortest way of writting a "for loop"
-------------------------------------------------------------------

It can be created where -
1. expression-1 is missing
2. expression-2 is missing
3. expression-3 is missing
4. even body is missing

for(;;);   ---> shortest form of writting a for loop


while loop terminated with a semicolon
---------------------------------------

expr-1
while(expr-2);
{
  ---------
  ---------
  ---------
}

Like "for" we can also have a "while-loop" terminated with semicolon.
In such a case again - consider it as a loop without any body to it.
i.e. body of such a loop is missing
For your easyness you can consider it as a loop with empty body to it (Technically Incorrect)
If you observe any block of code below such a while - then, just consider it as a arbitary block of code
It's not the body of while.

The below for is perfectly valid - 

for (i = 1, fact=1 ; i <= no; ++i)
{
	fact *= i;
}

i = 1, fact=1 is representing the expression-1.
Here the ,(comma) is acting as the operator.
Because of this multiple initializations are allowed in the place of expr-1 in case of "for loop"


Few Assignments 

1. Perfect Number 
2. Factorial of a Number
3. Sum of digits of a user entered number 
4. Sum of cubes of individual digits of a number is it equal to the number itself 

Check whether a user entered number is armstrong or not 

Wrong Statement :- Sum of cubes of individual digits if it gets equal to the number itself. 
Then the number is an armstrong number. 

Right :- It depends upon the total number of digits.
         We need to take power of the total number of digits

5. Fibonacii Series 
6. Prime Number 
7. Table of integers in the range 2 to 7 ( Till 10 terms )
8. Factorial of integers in the range 2 to 7 

9. *********   (Column size is 9 nd rows size is 3 )
   *********
   *********

10. 123456789   (Column size is 9 nd rows size is 3 )
    123456789
    123456789

11. 111111111   (Column size is 9 nd rows size is 3 )
    222222222
    333333333


12.

*
**
***
****
*****
******

13.

1
12
123
1234
12345
123456


14. 

******
*****
****
***
**
*

15. 

123456
12345
1234
123
12
1

16. Printing "first 25 prime numbers"
(I am not asking you to display prime numbers in the range 1 to 25) 

eg:- 2, 3, 5, 7, 11, 13, 17, ......................( First 25 prime numbers )

//No. of iterations are not well known in advance i.e. it's undefined so, preferably use a while-loop.


Taking a very important turn over the study of the language 'C'
----------------------------------------------------------------

Function
---------


int main( void )
{
   -------------
   -------------
   -------------
   -------------

   return 0;
}

Before technical understanding of functions :- 

A function is nothing, but a readymade tool which is dedicated towards performing of some specific task.

eg :-

printf ---> displaying some text onto the console/output screen
scanf  ---> read some quantity from the console/output screen 
            and
            store it in the required variable/L-Value
exit  ----> to terminate the complete execution of the program/application

As a beginer just understand
1. The name of the function.
2. The task it's dedicated for.
3. The way to use i.e. the general syntax of using it i.e the way to call it.
4. The time to use it in the program.


"printf", "scanf", "exit"..... are the examples of built-in-functions. (It's readily available 
for the use. Don't worry about the internals of it. Simply use it as and when required)
The defination of it i.e. the body of these b.i.f resides inside the ".LIB" folder.
Header file never contains the defination of the function. It contains the declaration of it.

eg:- declaration of "printf" and "scanf" we can observe in the header file "stdio.h"
     declaration of "exit" we can observe in the header file "stlib.h"


Let's talk something about "main"

int main( void )
{
   -------------
   -------------
   -------------
   -------------

   return 0;
}

"main" is purely a user defined function
It's we the programmers/developers/learners/etc... who are providing the defination for it.
Above main serves as an example for - "defination of the function with name main being provided"

Technically speaking a function is just a block of code ({ -------- }) in which we have the relevant
set of statements whoe's execution is required for completion of some specific task.

eg:- 

return_type  name_of_the_function ( argument list if any seperated by a comma ) 
{
  ------------
  ------------
  ------------
}

void calculateSquareAndDisplay( int no )
{
  -----------
  -----------
  -----------
}

There are two types of functions - 

a. Built-in functions

b. User-defined functions

In this due course of time we will define functions of our own like built-in functions.
Such functions would be termed as - user defined functions.


